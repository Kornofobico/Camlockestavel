--[[ 
    Aimbot V5 (COM AUTO FIRE)
    - Painel com TopBar (título + minimizar) + botão flutuante para reabrir
    - Seções com UIListLayout + UIPadding (layout estável e responsivo)
    - Aimlock ON/OFF, Distância (studs), Suavidade, FOV
    - Seletor de Parte Alvo (Head/HumanoidRootPart/Upper/LowerTorso)
    - Whitelist de Times (ilimitado)
    - Stick no alvo atual até ficar inválido (morto/fora de visão/fora do range)
    - Wallcheck (raycast)
    - Rótulo "INIMIGO" no topo central da tela
    - AUTO FIRE (dispara automaticamente quando tem alvo)
--]]

--// Serviços
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

--// Estado
local aimlockEnabled = false
local autoFireEnabled = false
local currentTarget -- BasePart (da parte alvo)
local maxDistance = 500
local lerpSpeed = 0.15
local fov = 100 -- FOV adicionado (interpreto como raio em pixels)

local selectedPart = "Head"
local possibleParts = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}

local whitelistedTeams: {[string]: boolean} = {}
local activeESP = {}
local espUpdater -- connection/timer
local enemyLabel -- topo da tela
local screenGui -- raiz da GUI
local mainFrame -- painel principal
local openPanelButton -- botão flutuante
local lastESPUpdate = 0
local ESP_UPDATE_INTERVAL = 0.35
local lastAutoFireTime = 0
local autoFireDelay = 0.1 -- Delay entre disparos (segundos)

--// FOV Circle (GUI-based visual, substitui Drawing)
local fovGuiFrame
local function createOrUpdateFOVGui()
    -- garante que a GUI raiz exista antes de criar o círculo
    if not screenGui or not screenGui.Parent then return end

    local radius = math.clamp(tonumber(fov) or 100, 1, 2000)
    local size = radius * 2

    if not fovGuiFrame or not fovGuiFrame.Parent then
        fovGuiFrame = Instance.new("Frame")
        fovGuiFrame.Name = "FOVCircle"
        fovGuiFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        fovGuiFrame.BackgroundTransparency = 1 -- sem preenchimento visível
        fovGuiFrame.Size = UDim2.new(0, size, 0, size)
        fovGuiFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        fovGuiFrame.ZIndex = 9998
        fovGuiFrame.Parent = screenGui

        -- UICorner para transformar o frame em círculo (quando é quadrado)
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = fovGuiFrame

        -- UIStroke para desenhar a borda do círculo
        local stroke = Instance.new("UIStroke")
        stroke.Name = "FOVStroke"
        stroke.Color = Color3.fromRGB(0, 255, 0)
        stroke.Thickness = 2
        stroke.Transparency = 0.4
        stroke.Parent = fovGuiFrame
    else
        fovGuiFrame.Size = UDim2.new(0, size, 0, size)
        fovGuiFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        local stroke = fovGuiFrame:FindFirstChild("FOVStroke")
        if stroke and stroke:IsA("UIStroke") then
            stroke.Color = Color3.fromRGB(0, 255, 0)
            stroke.Transparency = 0.4
            stroke.Thickness = 2
        end
    end

    fovGuiFrame.Visible = aimlockEnabled
end

-- Atualiza círculo todo frame (mantém centralizado e com o raio atual)
RunService.RenderStepped:Connect(function()
    if fovGuiFrame and fovGuiFrame.Parent then
        local radius = math.clamp(tonumber(fov) or 100, 1, 2000)
        local size = radius * 2
        fovGuiFrame.Size = UDim2.new(0, size, 0, size)
        fovGuiFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
        -- visibilidade ligada ao estado do aimlock
        fovGuiFrame.Visible = aimlockEnabled
    end
end)

--// Util
local function onScreenAndVisible(part: BasePart)
    if not part then return false end
    -- On-screen
    local _, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    -- Wallcheck
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction, rayParams)
    return not result or result.Instance:IsDescendantOf(part.Parent)
end

local function isTargetValid(targetPart: BasePart)
    if not targetPart or not targetPart.Parent then return false end
    local char = targetPart.Parent
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    if (targetPart.Position - Camera.CFrame.Position).Magnitude > maxDistance then return false end
    if not onScreenAndVisible(targetPart) then return false end
    return true
end

local function getTeamName(player: Player)
    return (player.Team and player.Team.Name) or "__NO_TEAM__"
end

local function isInFOV(targetPart: BasePart)
    local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
    if not onScreen then return false end
    
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local point = Vector2.new(screenPoint.X, screenPoint.Y)
    local distance = (point - center).Magnitude
    
    return distance <= fov
end

local function getNearestEnemyPart()
    local closest: BasePart? = nil
    local shortest = math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local tname = getTeamName(p)
            if not whitelistedTeams[tname] then
                local hum = p.Character:FindFirstChildOfClass("Humanoid")
                local part = p.Character:FindFirstChild(selectedPart)
                if hum and hum.Health > 0 and part and part:IsA("BasePart") then
                    local dist = (part.Position - Camera.CFrame.Position).Magnitude
                    if dist < maxDistance and onScreenAndVisible(part) and dist < shortest and isInFOV(part) then
                        shortest = dist
                        closest = part
                    end
                end
            end
        end
    end
    return closest
end

--// Auto Fire
local function performAutoFire()
    if not autoFireEnabled then return end
    if not currentTarget or not isTargetValid(currentTarget) then return end
    
    local currentTime = tick()
    if currentTime - lastAutoFireTime >= autoFireDelay then
        lastAutoFireTime = currentTime
        
        -- Simular pressionar e soltar o botão de atirar
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.ButtonR2, false, nil)
            task.wait(0.05) -- Pequeno delay para garantir o disparo
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.ButtonR2, false, nil)
        end)
    end
end

--// GUI Helpers
local function makeButton(parent, text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, 0, 0, 32)
    b.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    b.TextColor3 = Color3.new(1,1,1)
    b.AutoButtonColor = true
    b.Text = text
    b.Font = Enum.Font.Gotham
    b.TextSize = 14
    b.Parent = parent
    Instance.new("UICorner", b).CornerRadius = UDim.new(0, 6)
    return b
end

local function makeSection(parent, titleText)
    local section = Instance.new("Frame")
    section.BackgroundTransparency = 1
    section.Size = UDim2.new(1, 0, 0, 10)
    section.Parent = parent

    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Size = UDim2.new(1, 0, 0, 22)
    title.Text = titleText
    title.TextColor3 = Color3.fromRGB(210,210,210)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 14
    title.Parent = section

    return section
end

local function makeInput(parent, placeholder, defaultText)
    local tb = Instance.new("TextBox")
    tb.Size = UDim2.new(1, 0, 0, 32)
    tb.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    tb.TextColor3 = Color3.new(1,1,1)
    tb.PlaceholderText = placeholder
    tb.Text = defaultText or ""
    tb.ClearTextOnFocus = false
    tb.Font = Enum.Font.Gotham
    tb.TextSize = 14
    tb.Parent = parent
    Instance.new("UICorner", tb).CornerRadius = UDim.new(0, 6)
    return tb
end

local function enableDrag(handle: Instance, dragTarget: Instance)
    local dragging, dragStart, startPos
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = dragTarget.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    handle.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            dragTarget.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

--// GUI Principal
local function createGui()
    if screenGui and screenGui.Parent then screenGui:Destroy() end

    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AimlockPanel"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    -- Label de status no topo central
    enemyLabel = Instance.new("TextLabel")
    enemyLabel.Size = UDim2.new(0, 220, 0, 30)
    enemyLabel.Position = UDim2.new(0.5, -110, 0.05, 0)
    enemyLabel.BackgroundTransparency = 1
    enemyLabel.Text = ""
    enemyLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
    enemyLabel.TextScaled = true
    enemyLabel.Font = Enum.Font.GothamBold
    enemyLabel.Parent = screenGui

    -- Botão flutuante para abrir painel
    openPanelButton = Instance.new("TextButton")
    openPanelButton.Size = UDim2.new(0, 120, 0, 32)
    openPanelButton.Position = UDim2.new(0.02, 0, 0.9, 0)
    openPanelButton.Text = "Aimlock Menu"
    openPanelButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    openPanelButton.TextColor3 = Color3.new(1,1,1)
    openPanelButton.Font = Enum.Font.Gotham
    openPanelButton.TextSize = 14
    openPanelButton.Parent = screenGui
    Instance.new("UICorner", openPanelButton).CornerRadius = UDim.new(0, 6)

    -- Painel principal
    mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 290, 0, 500) -- Aumentado para acomodar Auto Fire
    mainFrame.Position = UDim2.new(0.06, 0, 0.2, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.Visible = true
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    local mainStroke = Instance.new("UIStroke", mainFrame)
    mainStroke.Color = Color3.fromRGB(70,70,70)
    mainStroke.Thickness = 1

    -- Top Bar
    local topBar = Instance.new("Frame")
    topBar.Size = UDim2.new(1, 0, 0, 36)
    topBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    topBar.BorderSizePixel = 0
    topBar.Parent = mainFrame
    Instance.new("UICorner", topBar).CornerRadius = UDim.new(0, 8)

    local title = Instance.new("TextLabel")
    title.BackgroundTransparency = 1
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Size = UDim2.new(1, -70, 1, 0)
    title.Position = UDim2.new(0, 12, 0, 0)
    title.Text = "AIMLOCK V5"
    title.TextColor3 = Color3.fromRGB(230,230,230)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16
    title.Parent = topBar

    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Size = UDim2.new(0, 32, 0, 28)
    minimizeButton.Position = UDim2.new(1, -40, 0.5, -14)
    minimizeButton.Text = "-"
    minimizeButton.TextScaled = true
    minimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    minimizeButton.TextColor3 = Color3.new(1,1,1)
    minimizeButton.Parent = topBar
    Instance.new("UICorner", minimizeButton).CornerRadius = UDim.new(0, 6)

    enableDrag(topBar, mainFrame)

    local function togglePanel()
        mainFrame.Visible = not mainFrame.Visible
    end
    openPanelButton.MouseButton1Click:Connect(togglePanel)
    minimizeButton.MouseButton1Click:Connect(togglePanel)

    -- Conteúdo (scroller vertical com seções)
    local content = Instance.new("ScrollingFrame")
    content.Size = UDim2.new(1, -16, 1, -52)
    content.Position = UDim2.new(0, 8, 0, 44)
    content.BackgroundTransparency = 1
    content.ScrollBarThickness = 6
    content.CanvasSize = UDim2.new(0, 0, 0, 0)
    content.AutomaticCanvasSize = Enum.AutomaticSize.Y
    content.Parent = mainFrame

    local padding = Instance.new("UIPadding", content)
    padding.PaddingTop = UDim.new(0, 6)
    padding.PaddingBottom = UDim.new(0, 8)
    padding.PaddingLeft = UDim.new(0, 4)
    padding.PaddingRight = UDim.new(0, 4)

    local list = Instance.new("UIListLayout", content)
    list.Padding = UDim.new(0, 10)
    list.SortOrder = Enum.SortOrder.LayoutOrder

    -- Seção: Controle
    makeSection(content, "CONTROLE")
    local toggleAim = makeButton(content, "Aimlock: OFF")
    toggleAim.MouseButton1Click:Connect(function()
        aimlockEnabled = not aimlockEnabled
        currentTarget = nil
        toggleAim.Text = "Aimlock: " .. (aimlockEnabled and "ON" or "OFF")
        toggleAim.BackgroundColor3 = aimlockEnabled and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(60, 60, 60)
        
        -- Atualizar visibilidade do FOV GUI
        if fovGuiFrame then
            fovGuiFrame.Visible = aimlockEnabled
        end
    end)

    -- Seção: Auto Fire
    makeSection(content, "AUTO FIRE")
    local toggleAutoFire = makeButton(content, "Auto Fire: OFF")
    toggleAutoFire.MouseButton1Click:Connect(function()
        autoFireEnabled = not autoFireEnabled
        toggleAutoFire.Text = "Auto Fire: " .. (autoFireEnabled and "ON" or "OFF")
        toggleAutoFire.BackgroundColor3 = autoFireEnabled and Color3.fromRGB(170, 0, 0) or Color3.fromRGB(60, 60, 60)
    end)

    -- Seção: Parâmetros
    makeSection(content, "PARÂMETROS")
    local distanceBox = makeInput(content, "Distância (studs)", tostring(maxDistance))
    distanceBox.FocusLost:Connect(function()
        local num = tonumber(distanceBox.Text)
        if num and num > 0 then
            maxDistance = num
            distanceBox.Text = tostring(num)
        else
            distanceBox.Text = tostring(maxDistance)
        end
    end)

    local smoothBox = makeInput(content, "Suavidade (0.01 - 1.0)", tostring(lerpSpeed))
    smoothBox.FocusLost:Connect(function()
        local num = tonumber(smoothBox.Text)
        if num and num > 0 and num <= 1 then
            lerpSpeed = num
            smoothBox.Text = tostring(num)
        else
            smoothBox.Text = tostring(lerpSpeed)
        end
    end)

    -- Seção: FOV
    makeSection(content, "FOV")
    local fovBox = makeInput(content, "FOV (1-500)", tostring(fov))
    fovBox.FocusLost:Connect(function()
        local num = tonumber(fovBox.Text)
        if num and num >= 1 and num <= 500 then
            fov = num
            fovBox.Text = tostring(num)
            createOrUpdateFOVGui()
            if fovGuiFrame then
                fovGuiFrame.Visible = aimlockEnabled
            end
        else
            fovBox.Text = tostring(fov)
        end
    end)

    -- Seção: Parte Alvo
    makeSection(content, "PARTE ALVO")
    local partList = Instance.new("ScrollingFrame")
    partList.Size = UDim2.new(1, 0, 0, 120)
    partList.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
    partList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    partList.ScrollBarThickness = 6
    partList.Parent = content
    Instance.new("UICorner", partList).CornerRadius = UDim.new(0, 6)
    local partPad = Instance.new("UIPadding", partList)
    partPad.PaddingTop = UDim.new(0, 6)
    partPad.PaddingLeft = UDim.new(0, 6)
    partPad.PaddingRight = UDim.new(0, 6)
    partPad.PaddingBottom = UDim.new(0, 6)
    local partLayout = Instance.new("UIListLayout", partList)
    partLayout.Padding = UDim.new(0, 6)
    partLayout.SortOrder = Enum.SortOrder.LayoutOrder

    local function refreshPartButtons()
        for _, child in ipairs(partList:GetChildren()) do
            if child:IsA("TextButton") then child:Destroy() end
        end
        for _, name in ipairs(possibleParts) do
            local b = makeButton(partList, (selectedPart == name and "[✓] " or "[ ] ") .. name)
            b.MouseButton1Click:Connect(function()
                selectedPart = name
                for _, other in ipairs(partList:GetChildren()) do
                    if other:IsA("TextButton") then
                        local clean = other.Text:match("%w+$")
                        other.Text = "[ ] " .. (clean or "")
                    end
                end
                b.Text = "[✓] " .. name
                currentTarget = nil -- força revalidação com a nova parte
            end)
        end
    end
    refreshPartButtons()

    -- Seção: Whitelist de Times
    makeSection(content, "WHITELIST DE TIMES")
    local teamList = Instance.new("ScrollingFrame")
    teamList.Size = UDim2.new(1, 0, 0, 150)
    teamList.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
    teamList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    teamList.ScrollBarThickness = 6
    teamList.Parent = content
    Instance.new("UICorner", teamList).CornerRadius = UDim.new(0, 6)
    local teamPad = Instance.new("UIPadding", teamList)
    teamPad.PaddingTop = UDim.new(0, 6)
    teamPad.PaddingLeft = UDim.new(0, 6)
    teamPad.PaddingRight = UDim.new(0, 6)
    teamPad.PaddingBottom = UDim.new(0, 6)
    local teamLayout = Instance.new("UIListLayout", teamList)
    teamLayout.Padding = UDim.new(0, 6)
    teamLayout.SortOrder = Enum.SortOrder.LayoutOrder

    local function addTeamButtons()
        for _, t in ipairs(Teams:GetTeams()) do
            local isOn = whitelistedTeams[t.Name] == true
            local b = makeButton(teamList, (isOn and "[✓] " or "[ ] ") .. t.Name)
            b.MouseButton1Click:Connect(function()
                whitelistedTeams[t.Name] = not whitelistedTeams[t.Name] or nil
                local nowOn = whitelistedTeams[t.Name] == true
                b.Text = (nowOn and "[✓] " or "[ ] ") .. t.Name
                -- atualizar ESP para refletir exclusão de aliados
            end)
        end
    end
    addTeamButtons()

    -- Segurança: se times mudarem após o join, recarregar a lista
    Teams.ChildAdded:Connect(function() addTeamButtons() end)
    Teams.ChildRemoved:Connect(function() addTeamButtons() end)
end

--// Loop principal
local rsConn = RunService.RenderStepped:Connect(function(dt)
    if aimlockEnabled then
        if not isTargetValid(currentTarget) then
            currentTarget = getNearestEnemyPart()
        end
        if currentTarget then
            local pos = Camera.CFrame.Position
            local targetPos = currentTarget.Position
            local desired = CFrame.new(pos, targetPos)
            Camera.CFrame = Camera.CFrame:Lerp(desired, lerpSpeed)
            
            -- Executar Auto Fire se estiver habilitado
            performAutoFire()
        end

        if enemyLabel then
            enemyLabel.Text = (currentTarget and isTargetValid(currentTarget)) and "INIMIGO" or ""
        end

    else
        if enemyLabel then enemyLabel.Text = "" end
    end
end)

--// Inicialização GUI e FOV
createGui()
createOrUpdateFOVGui()

-- Atualizar FOV quando a tela mudar de tamanho (recria/atualiza propriedades)
Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    createOrUpdateFOVGui()
end)

-- Garantir que a GUI volte após respawn (sem sumir botão)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.8)
    if not LocalPlayer.PlayerGui:FindFirstChild("AimlockPanel") then
        createGui()
        createOrUpdateFOVGui()
    end
end)

--// BOTÃO ON/OFF FLUTUANTE PARA AIMLOCK
local floatingToggle = Instance.new("TextButton")
floatingToggle.Name = "FloatingAimToggle"
floatingToggle.Size = UDim2.new(0, 120, 0, 40)
floatingToggle.Position = UDim2.new(0.8, 0, 0.1, 0)
floatingToggle.Text = "Aimlock: OFF"
floatingToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
floatingToggle.TextColor3 = Color3.new(1,1,1)
floatingToggle.Font = Enum.Font.GothamBold
floatingToggle.TextSize = 14
floatingToggle.Parent = screenGui
Instance.new("UICorner", floatingToggle).CornerRadius = UDim.new(0, 8)

-- Atualiza o botão ao clicar
floatingToggle.MouseButton1Click:Connect(function()
    aimlockEnabled = not aimlockEnabled
    currentTarget = nil

    floatingToggle.Text = "Aimlock: " .. (aimlockEnabled and "ON" or "OFF")
    floatingToggle.BackgroundColor3 = aimlockEnabled and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(50, 50, 50)

    if fovGuiFrame then
        fovGuiFrame.Visible = aimlockEnabled
    end
end)

--// FUNÇÃO DE ARRASTAR QUALQUER BOTÃO
local function draggable(btn)
    local dragging = false
    local dragStart = nil
    local startPos = nil

    btn.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or
           input.UserInputType == Enum.UserInputType.Touch then
            
            dragging = true
            dragStart = input.Position
            startPos = btn.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    btn.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or
                         input.UserInputType == Enum.UserInputType.Touch) then

            local delta = input.Position - dragStart
            btn.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
end

draggable(floatingToggle)

-- Script feito por Kipressao11 (NOTIF) - renomeei a GUI para evitar conflito com screenGui
-- Coloque este script em StarterGui (como LocalScript) — mantive aqui só para compatibilidade
local notifGui = Instance.new("ScreenGui")
notifGui.Name = "Kipressao11_Notification"
notifGui.ResetOnSpawn = false
notifGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 300, 0, 50)
frame.Position = UDim2.new(0, 10, 1, -60) -- canto inferior esquerdo
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BackgroundTransparency = 0.2
frame.BorderSizePixel = 0
frame.Parent = notifGui

local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, -10, 1, 0)
textLabel.Position = UDim2.new(0, 5, 0, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "Script feito por Kipressao11"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.TextScaled = true
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextXAlignment = Enum.TextXAlignment.Left
textLabel.Parent = frame

frame.BackgroundTransparency = 1
textLabel.TextTransparency = 1

for i = 1, 10 do
    frame.BackgroundTransparency = 1 - i * 0.08
    textLabel.TextTransparency = 1 - i * 0.1
    task.wait(0.05)
end

wait(5) -- tempo que fica visível

for i = 1, 10 do
    frame.BackgroundTransparency = i * 0.1
    textLabel.TextTransparency = i * 0.1
    task.wait(0.05)
end

notifGui:Destroy()